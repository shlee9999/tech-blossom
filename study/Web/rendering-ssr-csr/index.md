---
slug: rendering-ssr-csr
authors: [shlee]
tags: [Web]
---

# SSR vs CSR

이 글은 1990년대부터 현재까지의 렌더링 방식의 변천사를 큰 흐름으로 훑고, SSR/CSR의 명확한 장단점 비교와 함께 SSG, Universal Rendering까지 한 번에 이해하도록 돕습니다.

<!-- truncate -->

## 1) 1990년대 → 2000년대 초: MPA 중심, 전통적 SSR의 시대
- **MPA(Multi-Page Application)**: 각 URL 요청마다 서버가 새로운 HTML 문서를 만들어 응답. 대부분의 동적 웹은 JSP, PHP, ASP 같은 **서버 템플릿**을 통해 렌더링했습니다. 즉, 기본이 **SSR**이었습니다.
- 장점: 첫 화면이 빠르고, 검색엔진 친화적이며, 접근성과 링크 공유가 쉬움.
- 한계: 페이지 전환마다 전체 문서를 새로 고침하므로 인터랙션이 끊기고, 클라이언트 측 리치 UI가 제한적.

## 2) 2010년대 초중반: AJAX, SPA, CSR의 부상
- **AJAX**와 **브라우저 성능 향상**으로 클라이언트에서 상태를 관리하며 페이지를 조립하는 **SPA(Single-Page Application)**가 대중화.
- 대표 프레임워크: Angular, React, Vue. 라우팅과 상태 관리, 데이터 페칭을 클라이언트에서 처리하는 **CSR** 패턴이 보편화.
- 장점: 부드러운 화면 전환, 앱 같은 사용자 경험(offline, rich interactions).
- 한계: 초기 로딩 번들 크기가 커지면 첫 화면이 늦고, SEO 대응이 까다로움(특히 크롤러가 JS 실행을 제대로 못하던 시절).

## 3) 2010년대 후반 → 현재: 하이브리드의 시대(SSR 재부상, SSG, Universal Rendering)
- **SSR 재부상**: 초기 페인트를 빠르게 하고 SEO 이슈를 해결하려는 요구. Next.js, Nuxt 등은 라우트별로 SSR을 쉽게 제공.
- **SSG(Static Site Generation)**: 빌드 타임에 HTML을 만들어 CDN에 배포. 블로그/문서/마케팅 사이트에 이상적. 트래픽 급증에도 안정적이고 저비용.
- **Universal Rendering(Isomorphic Rendering)**: 동일한 컴포넌트 코드를 서버에서도, 클라이언트에서도 실행. 서버에서 미리 렌더링하고 클라이언트에서 재수화(hydration)하여 인터랙션을 붙이는 방식. 필요에 따라 **SSR + CSR**을 조합.
- 최신 추세: **부분 하이드레이션, 스트리밍 SSR, ISR(Incremental Static Regeneration)**, **RSC(React Server Components)** 등으로 더 세밀한 타협안 등장.

## 핵심 개념 한눈에 보기
- **MPA**: 페이지 전환 시마다 HTML 전체를 서버에서 새로 렌더링해 전달. 전통적 SSR에 가깝다.
- **SPA**: 최초에 셸(프레임)과 번들을 받아, 이후엔 클라이언트 라우팅과 뷰 업데이트를 JS로 처리. 기본은 CSR.
- **SSR**: 요청 시점에 서버가 HTML을 만들어 전달. 초기 표시가 빠르고 SEO 유리. 이후 클라이언트에서 재수화로 인터랙션 활성화.
- **CSR**: 서버는 주로 빈 셸과 번들을 제공, 실제 화면 조립은 브라우저가 수행. 앱 같은 부드러운 UX.
- **SSG**: 빌드 타임에 정적 HTML을 생성해 배포. 요청 시 서버 연산이 거의 없음.
- **Universal Rendering**: 동일한 UI 코드를 서버(초기 렌더)와 클라이언트(상호작용) 양쪽에서 실행하는 아키텍처.

## SPA vs MPA 비교

| 기준 | SPA | MPA |
| --- | --- | --- |
| 초기 로딩 | 번들 크기에 따라 느릴 수 있음 | 대체로 빠름(SSR된 HTML 바로 표시) |
| 전환 경험 | 부드러운 전환, 앱-like | 전환 시 전체 새로고침으로 깜박임 가능 |
| SEO | 별도 대비 필요(SSR/SSG/프리렌더) | 유리(서버가 즉시 HTML 제공) |
| 복잡도 | 클라이언트 상태/라우팅/데이터 동기화 부담 큼 | 서버-클라이언트 경계가 비교적 단순 |
| 캐싱/배포 | 정적 자산 캐싱 중심 | 페이지 단위 캐싱 전략과 궁합 좋음 |

## SSR vs CSR 장단점 명확 비교

| 항목 | SSR | CSR |
| --- | --- | --- |
| 첫 화면 표시 속도 | 빠름(HTML 즉시 표시) | 번들 다운로드/실행 후 표시 → 느려질 수 있음 |
| SEO | 매우 유리 | 별도 대비 필요(프리렌더, SSR 도입 등) |
| 서버 비용 | 요청마다 서버 렌더링 비용 발생 | 상대적으로 적음(서버는 API/정적 제공 위주) |
| 클라이언트 부담 | 재수화 비용 존재(중간 이상 복잡도에서 부담) | 초기 렌더 비용과 상태 관리 부담이 큼 |
| 복잡성 | 서버·클라이언트 경계를 설계해야 함 | 클라이언트 아키텍처 복잡도 증가 |
| 캐싱 전략 | CDN + 페이지/데이터 캐싱 조합 | CDN 정적 자산 캐싱 중심 |
| 상호작용 응답성 | 초기엔 충분히 좋음, 이후는 CSR과 유사 | 번들 최적화/코드스플리팅 필수 |

요약: 초기 표시·SEO가 중요하면 SSR이 유리하고, 장기적으로 리치 인터랙션 중심이라면 CSR의 장점이 큽니다. 다만 현대 프레임워크는 둘을 **혼합**해서 최적점을 찾도록 돕습니다.

## SSG와 Universal Rendering은 언제 유리할까?
- **SSG**
  - 콘텐츠가 자주 변하지 않고, 읽기 위주(블로그/문서/마케팅)일 때 최적.
  - CDN 캐싱으로 전 세계 어디서나 빠르고 저렴.
  - 변경이 잦다면 **ISR(증분 정적 재생성)** 같이 일부 페이지만 다시 빌드하는 전략을 고려.
- **Universal Rendering**
  - 동일 UI를 서버 초기에 렌더링하고, 클라이언트에서 재수화하여 인터랙션을 붙임.
  - 라우트나 컴포넌트별로 SSR/CSR/SSG를 선택해 **하이브리드** 운영 가능.
  - 복잡한 앱에서 SEO, 성능, 개발 생산성의 균형을 잡는 현실적인 선택지.

## 무엇을 선택할까? 실전 가이드
- **블로그/문서/마케팅 페이지**: SSG(+ ISR) 권장. 필요 페이지만 온디맨드로 재생성.
- **검색 유입이 핵심인 커머스/콘텐츠 목록**: SSR 또는 하이브리드(상단 폴드 SSR, 나머지 CSR/지연 하이드레이션).
- **대시보드/내부 툴**: CSR 중심 + 코드 스플리팅/지연 로딩. SEO 부담 적고 인터랙션 많음.
- **초기 로딩이 너무 느린 SPA**: 핵심 경로만 SSR/Streaming SSR을 도입해 TTFB와 LCP 개선.
- **초고트래픽**: SSG로 캐시 친화 설계 + API 레벨 캐싱/에지 렌더링 검토.

## 마지막 한 줄 정리
- **MPA→SPA→하이브리드**로 진화해 왔으며, 오늘날에는 **SSG, SSR, CSR, Universal Rendering**을 상황별로 조합하는 것이 정석입니다. 핵심은 “우리 사용자와 트래픽, 콘텐츠 특성에 맞는 적절한 혼합”입니다.


