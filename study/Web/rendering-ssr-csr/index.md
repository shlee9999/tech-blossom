---
slug: rendering-ssr-csr
authors: [shlee]
tags: [Web]
---

# SSR vs CSR

## 개요

1990년대부터 현재까지의 **렌더링 방식의 변천사**를 큰 흐름으로 훑고, **SSR/CSR의 명확한 비교**와 함께 SSG, Universal Rendering까지 한 번에 이해하도록 돕는 글입니다.


## 1) 1990년대 → 2000년대 초: MPA 중심, 전통적 SSR의 시대
- **MPA(Multi-Page Application)**: 각 URL 요청마다 서버가 새로운 HTML 문서를 만들어 응답. 대부분의 동적 웹은 JSP, PHP, ASP 같은 <TermTooltip termId="server_template">서버 템플릿</TermTooltip>을 통해 렌더링했습니다. 즉, 기본이 **전통적 SSR**이었습니다.
- **전통적 SSR의 특징**: 서버에서 완성된 HTML을 생성해 클라이언트에 전송하면, 브라우저는 이를 그대로 렌더링. JavaScript가 포함될 수 있지만 **하이드레이션 과정은 없습니다**. 동적 기능은 주로 전체 페이지 새로고침이나 단순한 DOM 조작으로 처리했습니다.
- 장점: 첫 화면이 빠르고, 검색엔진 친화적이며, 접근성과 링크 공유가 쉬움.
- 한계: 페이지 전환마다 전체 문서를 새로 고침하므로 인터랙션이 끊기고, 클라이언트 측 리치 UI가 제한적.

## 2) 2010년대 초중반: AJAX, SPA, CSR의 부상
- **AJAX**와 **브라우저 성능 향상**으로 클라이언트에서 상태를 관리하며 페이지를 조립하는 **SPA** (Single-Page Application)가 대중화.
- 대표 프레임워크: Angular, React, Vue. 라우팅과 상태 관리, 데이터 페칭을 클라이언트에서 처리하는 **CSR** 패턴이 보편화.
- 장점: 부드러운 화면 전환, 앱 같은 사용자 경험(offline, rich interactions).
- 한계: 초기 로딩 번들 크기가 커지면 첫 화면이 늦고, SEO 대응이 까다로움(특히 크롤러가 JS 실행을 제대로 못하던 시절).

## 3) 2010년대 후반 → 현재: 하이브리드의 시대(SSR 재부상, SSG, Universal Rendering)
- **SSR 재부상**: 초기 페인트를 빠르게 하고 SEO 이슈를 해결하려는 요구. Next.js, Nuxt 등은 라우트별로 SSR을 쉽게 제공.
- **SSG(Static Site Generation)**: 빌드 타임에 HTML을 만들어 CDN에 배포. 블로그/문서/마케팅 사이트에 이상적. 트래픽 급증에도 안정적이고 저비용.
- **Universal Rendering(Isomorphic Rendering)**: 서버와 클라이언트 양쪽에서 동일한 코드를 실행하는 방식. 전통적 SSR과의 핵심 차이점은 **하이드레이션(Hydration)** 과정입니다.
  - 서버에서 초기 HTML을 렌더링해 빠른 로딩과 SEO 제공
  - 클라이언트에서 이 HTML을 받아 JavaScript가 활성화되며 인터랙티브한 상태로 변환
  - **하이드레이션**: 서버 렌더링된 HTML에 React 같은 라이브러리가 이벤트 리스너와 상태 관리를 붙여 동적 UI로 만드는 과정
  - Next.js, Nuxt.js 등이 대표적인 예시
<!-- - 최신 추세: **부분 하이드레이션, 스트리밍 SSR, ISR(Incremental Static Regeneration)**, **RSC(React Server Components)** 등으로 더 세밀한 타협안 등장. -->

## SSG와 Universal Rendering은 언제 유리할까?
- **SSG**
  - 콘텐츠가 자주 변하지 않고, 읽기 위주(블로그/문서/마케팅)일 때 최적.
  - CDN 캐싱으로 전 세계 어디서나 빠르고 저렴.
  - 변경이 잦다면 **ISR(증분 정적 재생성)** 같이 일부 페이지만 다시 빌드하는 전략을 고려.
- **Universal Rendering**
  - 동일 UI를 서버 초기에 렌더링하고, 클라이언트에서 재수화하여 인터랙션을 붙임.
  - 라우트나 컴포넌트별로 SSR/CSR/SSG를 선택해 **하이브리드** 운영 가능.
  - 복잡한 앱에서 SEO, 성능, 개발 생산성의 균형을 잡는 현실적인 선택지.

## 전통적 SSR vs 현대적 SSR (Universal Rendering)

많은 개발자들이 헷갈리는 부분을 명확히 구분해보겠습니다.

| 구분 | 전통적 SSR (JSP, PHP 등) | 현대적 SSR (Universal Rendering) |
|------|-------------------------|--------------------------------|
| **렌더링 주체** | 서버에서만 HTML 생성 | 서버에서 초기 HTML 생성 + 클라이언트에서 하이드레이션 |
| **JavaScript 역할** | 단순 DOM 조작, 이벤트 처리 | React/Vue 등 프레임워크가 상태 관리와 라우팅 담당 |
| **하이드레이션** | **없음** | **있음** (핵심 차이점) |
| **페이지 전환** | 전체 새로고침 | 클라이언트 사이드 라우팅 |
| **상태 관리** | 세션, 쿠키, URL 파라미터 | JavaScript 상태 + 서버 상태 동기화 |
| **인터랙션** | 제한적 (폼 제출, 간단한 JS) | 리치한 SPA 수준의 인터랙션 |

:::tip 핵심 차이점
전통적 SSR에서는 서버가 완성된 HTML을 보내면 끝이지만, Universal Rendering에서는 **하이드레이션 과정**을 통해 클라이언트에서 동적 UI가 활성화됩니다.
:::
## CSR vs 전통적 SSR vs 현대적 SSR 비교

| 항목 | CSR | 전통적 SSR | 현대적 SSR (Universal) |
| --- | --- | --- | --- |
| **첫 화면 표시 속도** | 번들 다운로드/실행 후 표시 → 느려질 수 있음 | 빠름(HTML 즉시 표시) | 빠름(HTML 즉시 표시) |
| **SEO** | 별도 대비 필요 | 매우 유리 | 매우 유리 |
| **하이드레이션** | 없음 (처음부터 클라이언트 렌더링) | **없음** | **있음** |
| **페이지 전환** | 클라이언트 라우팅 (부드러움) | 전체 새로고침 (끊김) | 클라이언트 라우팅 (부드러움) |
| **서버 비용** | 적음 (API/정적 제공) | 중간 (렌더링 비용) | 높음 (렌더링 + 복잡도) |
| **클라이언트 부담** | 높음 (모든 렌더링 담당) | 낮음 (HTML만 표시) | 중간 (하이드레이션 비용) |
| **개발 복잡성** | 중간 (클라이언트 중심) | 낮음 (전통적 방식) | 높음 (서버/클라이언트 경계 설계) |
| **상호작용 응답성** | 높음 (최적화 필요) | 낮음 (새로고침 방식) | 높음 (하이드레이션 후) |

:::danger 주의사항
현대적 SSR 프레임워크(Next.js, Nuxt.js)를 사용할 때는 하이드레이션 과정에서 서버와 클라이언트 간 렌더링 결과가 다르면 **하이드레이션 미스매치** 오류가 발생할 수 있습니다.
:::



